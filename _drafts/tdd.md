---
title: "TDD"
layout: post
---


Мысли о TDD(и о тестировании вцелом).

Терминология:

Ручные тесты (Manual tests)
Функционал тестируется вручную на «живой» системе, использую стандартный для нее UI.
Это обычный, традиционный метод тестинга для QA.

Функциональные тесты (Functional tests)
Программист пишет некое «тестовое» UI, которое позволяет запускать определенные сценарии на «живой» системе, с взаимодействием настоящих модулей.
Это весьма распространенный метод тестирования, используемый программистами.
(я знал такие тесты как интеграционные)

Юнит тесты (Unit tests)
Программист пишет тесты, которые способны выполняться в «изолированной» среде – без других модулей. Прочие модули, к которым в процессе работы, должен обращаться тестируемый код, заменяются на на Моки (mocks). Таким образом, тесты могут исполняться в автоматическом режиме, на билд-машине, после компиляции.
Существует тренд на использование таких тестов. И программисты испытывают давление (моральное и административное), с тем чтобы перейти на их использование.

Суть:

Один чувак(http://habrahabr.ru/post/207448/) считает, что даже юнит тесты - это лишнее, ибо для них приходится писать больше кода, но они дают мало выигрыша, показывая только ошибки кода, но не интерфейсов, ui или иных, а ошибок окда как правило меньшинство.
И такие тесты стоит употреблять в критичных системах, или очень частоиспользуемых(типо библиотеки утилит).

С этим соглашался Макс Лапшин в рассылке рельс или эрланга(надо найти). Он говорил, что юнит тесты ломаются слишком часто, в отличие от функциональных, при каждом изменении класса, и получаются, на них только тратишь время. Также, что одна ошибка в программе может привести за собой лавину ошибок в взаимосвязанных тестах(однако здесь чувствуется лукавство, если тесты написано действительно unit - т.е. изолированно, то должны падать только единичные, верно указывающие тесты). А также, что моки - в целом зло, они не показываются ошибок реального сервиса, т.к. ты сам определяшь, что ждешь в ответ, и можешь ошибится в ожиданиях, + нужно много времени на их поддержку, которое не стоит того. Сам Макс внесто моканье сервисов перешел на другую модель - пишет внесто мока сервер, отвечающий мокаемому апи, что позволяется выгрести, к примеру, такие ошибки, как отсутсвие декодирования json, и т.п.

В этом есть своя логика, и она мне, как ленивому, понятна и я считаю её справедливой. Юнит тесты нужно чаще переписывать и поддерживать, и это не относится к рискам системы(о чем опять же говорил Лапшин), ведь тесты на самом деле должны компенсировать риски, быть на них ответом.

Юнит тесты, и тдд в особенности не являются ответом на такие риски, или, отвечают слишком многословно, и всё равно необходимо функциональное тестирование.

Для себя(на сей день) я вывел однозначную необходимость в тестировании интерфейсов, а внутренних модулей - по возможности.


Здесь (http://habrahabr.ru/post/225929/), чувак предлагает вводить тдд на обнаруженных багах, тогда цикл red-green-refactor получается более естественным, т.к. red возник сам собой.
Для меня это интересная идея, т.к. отношения к регрессионному тестированию я, к сожалению, пока имею мало.
Также он привносит идею, что tdd позволяет посмотреть на свой код с нескольких сторон(быть клиентом своего же кода), что в лучшую сторону сказывается на архитектуре.
Цитата:
"На мой взгляд, TDD позволяет изучать дизайн кода аналогичным образом. Он позволяет выйти за пределы обычного программирования, предоставляя программисту возможность оценивать код в критериях высокого уровня, а-ля «я легко могу протестировать это», или «я могу отделить этот код из его контекста, чтобы запускать в изолированном окружении» или «я могу добавить новое поведение через добавление кода, а не через изменение существующего». Вы можете возразить, что такие оценки можно получить, даже просто читая и обсуждая код, но именно TDD мотивирует программиста вести диалог с кодом, обдумывать «как должен вести себя этот кусок?» или «как мне следует спроектировать эту часть?» с разных сторон. Я думаю, что такой диалоговый стиль создания кода позволяет нарабатывать опыт куда эффективнее и быстрее, нежели традиционный подход «пиши много, читай редко». Как минимум, TDD мотивирует программиста видеть код под разными точами зрения."
Эта мысль также находит во мне отклик.
Однако, с продолжением я согласен не вполне:
"Главную роль в этом подходе играет рефакторинг. Во время рефакторинга требуется оценить существующий код, понять и выявить его проблемы, предложить способ его улучшения, а затем изменить в соответствии с этим способом. (Не хотелось бы мне проводить крупный рефакторинг без тестов, а если бы я не писал тесты в первую очередь, то вряд ли бы их набралось достаточно много, чтобы я чувствовал себя достаточно уверенно при рефакторинге.) Процесс рефакторинга позволяет программисту видеть разные варианты дизайна одного и того же кода, каждый из которых может либо иметь определённые проблемы, либо не иметь; это позволяет сравнивать различные варианты дизайна и выбирать из них наиболее достойные. У программиста появляется возможность сравнивать состояния «до» и «после» рефакторинга и оценивать, какой эффект дают его улучшения кода."

Разве функциональные тесты, покрывающие риски, не могут служить такой же надежной основой от нарушениях работы при рефакторинге? Если не могут, то разве не являются они тогда не обеспечивающими покрытие рисков?
Насколько велик профит от TDD в построении модульной архитектуре перед уделением того же времени на проектирование?
Не будут ли обеспечивать высокоуровневые тесты достаточную возможность рефакторинга?

Ещё, мне нравится идея тестов в браузере аля Selenium. Они тестируют реальную работу пользователей, достаточно удобно пишутся благодаря Selenium IDE(плагин для Firefox), и могут выловить такие ошибки, которые возможно найти только ручным тестированием.

На сей день - 11.09.15 - склоняюсь к такой мысли: на критичные к пользовательскому взаимодействию страницы(конфигурация, оплата, положить в корзину, etc, всё что реально не хочется чтобы не работало, так как бизнес огребет) стоит писать selenium тесты.
В целом - больше хороших интеграционных. На критичные(и слабо подверженные изменениям!) места системы можно писать unit тесты.
Однако - хорошие интеграционные не будут разве ловить ошибки частоиспользуемых модулей? Ведь если модуль упал, то всё упадет. Если только не неизвестный(пока!) косяк в алгоритме..

Также, читал недавно в ruby oject oriented programming(или как то так), что тдд используют те программисты, которые видят заранее дизайн системы, пусть не в мелочах, но в целом, и могут предвидеть, какие интерфейсы появятся.
Однако разве хорошее проектирование не дает те же удобства в руки начинающим программистам? Но зачем тогда tdd, если твоя система продумана? Хотя ты можешь в процессе увидеть более узкие места, при этом более прошаренные ребята могут сразу писать с минимальным проектированием.
Действительно ли они выигрывают время на этом, тдд лучше чем проектирование на более высоких уровнях? Тратится ли на написание тестов заранее и unit больше времени, чем на проектирование и функциональные? Получает ли мозг больший отклик в этом случае? Успевает отдыхать и рождать новые решения? Даже так - у какого подхода больше вероятность появления новых идей к системе, коду и рефакторингу, тдд или проектирование с функциональными?

Есть одна действительно правда хорошая вещь в тдд - ты можешь с помощью него быстрее писать функции(код) за счет того, что можешь сразу проверять ответ функции. Там, где я пишу в repl'e, и порой прямо копирую большие функции в консоль, тдд-программист сразу пишет тесты и затем их лишь прогоняет. Это должно ускорять реакцию, причем он может прогнать сразу несколько тестов, и получить ответ ещё быстрее.
Быстрее этого, пожалуй, только instant repl, который моментально показывает вычисленные изменения в коде (из LightTable, который, к сожалению, похоже умирает. Вдохновлен идеями Брет Виктора). На данный момент мы(программисты) вынуждены делать это в уме\, что сложнее и более склонно к ошибкам, и меньше - к быстрому ответу и творчеству. Может стоит развивать абстрактное мышление, но будет ли оно быстрее репла? не ошибется ли в усталую пятницу перед релизом?
Если бы можно было сформировать instant repl вместе с автоматическим "вытаскиванием" тестов из него - это была бы сказка.

Ещё один момент - тесты как документация. Кто говорит - да, кто говорит - бред всё это. Ктото писал, что начинает изучение системы всё-таки сперва с чтения кода, а потом уже, иногда, чтения тестов, т.к. тесты меньше говорят о системе(вроде как).

Я слабо представляю такое, опять же - если только как докуметация внешних интерфесой системы, чтобы была зависимость от входящих данных.
Если есть в классе неожиданное поведение - то это плохо в любом случае, а поймешь, что это неожиданно - неожиданно, и тесты тут уже слабо помогут)
Хотя, возможно, дело в том, что тесты пишут некачественно, и их попросту неприятно и неудобно читать.
