---
title:  "Наследование в Javascript"
categories: programming, javascript
layout: post
---
Наследование и работа классов в js больше похожа на языки Ruby и Python, чем C# и Java - экземпляры не создаются как штампованные копии класса, а делегируют вызовы функций классам как объектам райнтайма.


## Как это работает

Прототипы не копируют поведение, они просто связывают объекты и делегируют вызов методов.

У каждого объекта есть внутренняя ссылка `[[Prototype]]`, которая указывает на прототип объекта.
А у каждой функции есть специальное свойство `prototype` - это объект, на который будет указывать ссылка `[[Prototype]]` у объекта, созданного через `new Foo()`.
По умолчанию этот объект с единственным свойством constructor, указывающим на саму функцию.

Так что по факту в js нет классов как отдельных сущностей  - они строятся на функциях.

Представим такой объект

```javascript
function Foo() {};
Foo.prototype
//=> {constructor: ƒ Foo}
var foo = new Foo();
```

Объект `foo` будет иметь ссылку `[[Prototype]]` на объект `Foo.prototype` и делегировать ему вызов методов, если они не обнаружились у foo напрямую.
Если у первого объекта по ссылке `[[Prototype]]` не будет вызванного метода, то поиск будет идти рекурсивно по его ссылке `[[Prototype]]` до тех пор, пока не найдется нужное поле, либо `[[Prototype]]` не будет null.

Например

```javascript
function Foo() {}
Foo.prototype.my_method = function(x) { return x * 2 };

var foo = new Foo();
foo.my_method(3) // вернёт 6, вызвав метод Foo.prototype.my_method
foo.not_exist() // упадёт - метод не найден ни у текущего объекта, ни у одного из прототипов
```
Так как это делегирование, а не копирование, то возможно определить метод в прототипе после создания объекта, и всё будет работать:

```javascript
function Foo() {}
var foo = new Foo();

Foo.prototype.my_method = function(x) { return x * 2 };
foo.my_method(3) // тоже вернёт 6, вызвав метод Foo.prototype.my_method

Foo.prototype.my_method = function(x) { return x * 3 };
foo.my_method(3) // а теперь 9, т.к. ссылается на новый метод
```

Чтобы узнать, существует ли свойство в самом объекте, а не в его прототипе, нужно использовать `foo.hasOwnProperty('property_name')`.

Получить значение ссылки `[[Prototype]]` можно с помощью метода `Object.getPrototypeOf(foo)` или свойства `foo.__proto__`(которое является комбинацией геттера и сеттера).

Пример:

```javascript
var a = []
a.__proto__
// {constructor: ƒ Array, ... /* some Array methods */}
a.__proto__.__proto__
// {constructor: ƒ Object, ... /* some Object methods */}
a.__proto__.__proto__.__proto__
// null
```

## Специфика работы new

При вызове  `foo = new Foo()` происходит несколько вещей:

1. Вызывается функция Foo с переданными в неё аргументами и `this`  привязанным на объект, который будет экземпляром foo
2. Если Foo возвращает не примитивный тип(объект, массив, функцию), то из `new Foo()` вернётся этот объект - то есть это не будет созданием экземпляра.
3. Если Foo возвращает примитив, или ничего, то из `new Foo()`  вернется созданный объект, который был как `this` внутри конструктора и `[[Prototype]]` которого указывает на `Foo.prototype`

Примерный код того, как это работает:

```javascript
// how to new Foo works
inst = {};
res = Foo.call(inst);
if (res instanceof Object) {
    return res; // if Foo returns not primitive value, then it not used as prototype!
}
inst.__proto__ = Foo.prototype;
```

## Как работает наследование

Чтобы отнаследовать один класс от другого, нам нужно установить у него ссылку `[[Prototype]]` на родителя, и, если необходимо, вызвать в нашем конструкторе его конструктор.

Это можно сделать несколькими способами. Пусть есть две функции-класса:

```javascript
function Bar() {
    this.bar_opt = 'bar'
}
Bar.prototype.bar = function() { return this.bar_opt };

function Foo() {
    this.foo_opt = 'foo'
    Bar.call(this);
}
Foo.prototype.foo = function() { return this.foo_opt };
```

Варианты наследования Foo от Bar:

```javascript
// не делайте так! Foo.prototype станет ссылков на Bar.prototype - то тем же самым объектом.
// и если вы установите какие-нибудь методы в Foo.prototype после этого -
// они на самом деле установятся в Bar.prototype
Foo.prototype = Bar.prototype;

// этот вариант лучше, но вызовется конструктор Bar - скорее всего вам такого не нужно
Foo.prototype = new Bar();

// комбинация предыдущих двух методов, лишенная их недостатков, но с лишней переменной
var temp_fun = function() {};
temp_fun.prototype = Bar.prototype;
Foo.prototype = new temp_fun();

// Заменяем Foo.prototype новым объектом с установленным прототипом на Bar.prototype
Foo.prototype = Object.create(Bar.prototype);

// В предыдущих вариантах определение методов типо Foo.prototype.foo должно было идти после наследования -
// т.к. Foo.prototype заменялся другим объектом.

// т.к. __proto__ сеттер, то он работает корректно, в отличие от .prototype
Foo.prototype.__proto__ = Bar.prototype;
Object.setPrototypeOf(Foo.prototype, Bar.prototype);
```

## Затенение

Если методы или свойства, которые есть в Foo, переопределяются в инстанс foo, типо

```javascript
function Foo() {}
Foo.prototype.my_method = (x) => x * 2;

foo = new Foo()
foo.my_method = (x) => x * 3;

foo.my_method(3); // вернёт 9
```
то это называется **затенением** - когда поля или методы объекта переопределяют методы прототипа.

При этом есть два нюанса:

1. Если это свойство в прототипе определено как геттер с опцией `writtable: false`, то установка нового свойста иди вызовет ошибку в `strict mode` или будет проигнорировано в обычном.
2. Если это свойство в прототипе сеттер, то вызовется он, затенения не произойдет.

Но в обих случаях можно переписать свойство у экземпляра через defineProperty.


## Как узнать, что у объекта есть прототип

Есть два метода для того, чтобы узнать, является ли объект экземпляром какого-то прототипа. Это `Foo.prototype.isPrototypeOf(foo)` и  `foo instanceof Foo`.
Они оба проверяют, есть ли в цепочке прототипов объекта `foo`  прототип `Foo.prototype`. Разница между ними только в том, что первый можно вызвать от любого объекта, а второй - только от функции с существующим полем `prototype`.


## Классы ES6 и их отличия

Классы в ES6 построены на той же прототипной модели, т.е. в основном они добавляют только синтаксический сахар.

Но есть и несколько нововведений:

1. Раньше нельзя было нормально наследоваться от встроенных классов, типо Array(вот разные обходные пути http://speakingjs.com/es5/ch28.html), с es6 можно просто делать `MyArray extends Array`(причем это поведение невозможно воспроизвести транспайлером)
2. Объявления классов, в отличие от объявлений функций, не всплывают.
3. В методах классов есть метод `super`, ссылающийся на класс-родитель.
4. Появилось свойство `new.target` внутри функции или класса, которое указывает на функцию, вызванную через `new`. Если фукнция вызвана не через `new`, то это свойство будет `undefined`.
    Это свойство есть и в обычных фукнциях, но в классах при наследовании и вызове `super` оно сохраняет своё значение.
5. Различные проверки(например, что в конструкторе `super` должен быть вызван до вызова `this`)
6. Появился паттерн `species`, который позволяет указать, какой конструктор следует использовать для создания экземпляра в методах типо `Array.prototype.map()`, которые возвращают экземпляр. Например:

```javascript
class MyArray extends Array {
static get [Symbol.species]() {
    return Array;
}
}
let res = new MyArray().map(x => x);
res instanceof MyArray; //=> false
```

7. Изменена доступность атрибутов:
     Статические методы `Foo.*` доступны для записи и настройки, но не для перечисления.
    - Конструктор и объект в свойстве `prototype` имеют неизменяемые ссылки:
    Foo.prototype не доступен для записи, перечисления и настройки.
    Foo.prototype.constructor не доступен для записи, перечисления и настройки.
    - Прототипные методы `Foo.prototype.*` доступны для записи и настройки, но не для перечисления.




## Источники

[You don't know js](https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes)
https://frontender.info/es6-classes-final/
http://exploringjs.com/es6/ch_classes.html
